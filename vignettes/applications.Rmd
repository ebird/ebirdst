---
title: "eBird Status Data Products Applications"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{eBird Status Data Products Applications}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
.table {
    width: 50%;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, 
                      message = FALSE,
                      collapse = TRUE,
                      comment = "#>",
                      out.width = "100%",
                      fig.height = 4, 
                      fig.width = 7, 
                      fig.align = "center")
# only build vignettes locally and not for R CMD check
knitr::opts_chunk$set(eval = nzchar(Sys.getenv("BUILD_VIGNETTES")))
```

This vignette will cover a variety of common applications of the eBird Status Data Products including producing maps, plotting migration chronologies, and estimating the proportion of the population of a species within a region. In the introductory vignette we worked with the small example dataset for Yellow-bellied Sapsucker, which does not require a data access key to download. To provide more realistic examples, throughout this vignette we will use complete datasets for several species. As a result, a [data access key](https://ebird.github.io/ebirdst/articles/status.html#access) is required to run the code in this vignette.

We start by loading the packages used throughout this vignette.

```{r packages}
library(ebirdst)
library(terra)
library(sf)
library(dplyr)
library(tidyr)
library(rnaturalearth)
library(geodata)
library(ggplot2)
library(fields)
extract <- terra::extract
```

# Mapping relative abundance {#map}

In this section, we'll demonstrate how to make a simple map of relative abundance within a given region. As an example, we'll make a map of breeding season relative abundance for [Sage Trasher](https://ebird.org/species/sagthr) in Wyoming. The maps produced using this approach are suiteable for many applications; however, for high-quality publication-ready maps, it may be worthwhile using a traditional GIS environment such as QGIS or ArcGIS rather than R.

We start by downloading data for Sage Trasher and loading the breeding season relative abundance raster. The `pattern` argument to `ebirdst_download_status()` can be used to only download the specific files we need.

```{r map-load}
# download the yellow-bellied sapsucker data
ebirdst_download_status("sagthr",
                        pattern = "abundance_seasonal_mean")

# load seasonal mean relative abundance at 3km resolution
abd_seasonal <- load_raster("sagthr", 
                            product = "abundance", 
                            period = "seasonal",
                            metric = "mean",
                            resolution = "3km")

# extract just the breeding season relative abundance
abd_breeding <- abd_seasonal[["breeding"]]
```

The simplest way to map the seasonal relative abundance data is to use the built in `plot()` function from the `terra` package.

```{r map-simple, echo=-1}
par(mar = c(0.25, 0.25, 0.25, 2))
plot(abd_breeding, axes = FALSE)
```

Clearly this approach doesn't work out of the box! There are a wide variety of issues that we'll tackle one at a time.

## Cropping and masking

All raster data downloaded through this package are defined over the same global grid, regardless of the range of the individual species. As a result, mapping these data will produce a global map by default. However, Sage Thrasher only occurs in the western United States, which is barely visible in the global map. We need to constrain the extent of our map to make it more useful. For this example, we'll download a boundary for Wyoming (a state in the United States that harbours a large proportion of the breeding population of Sage Thrasher) and use it to crop and mask the relative abundance data. If you have a region defined in a Shapefile or GeoPackage you can instead load that regional polygon using `read_sf()`.

```{r map-extent, echo=-1}
par(mar = c(0.25, 0.25, 0.25, 0.25))
# wyoming boundary
region_boundary <- ne_states(iso_a2 = "US", returnclass = "sf") |> 
  filter(name == "Wyoming")

# project boundary to match raster data
region_boundary_proj <- st_transform(region_boundary, st_crs(abd_breeding))

# crop and mask to boundary of wyoming
abd_breeding_mask <- mask(abd_breeding, region_boundary_proj) |> 
  crop(region_boundary_proj)

# map the cropped data
plot(abd_breeding_mask, axes = FALSE)
```

## Projection

The raster data are all provided in the same equal area sinusoidal projection as NASA MODIS data. While this projection is suitable for analysis, it is not ideal for mapping since it introduces significant distortion. Instead, it's best to select an equal area projection tailored to your region. A good general purpose choice is a Lambert's azimuthal equal area projection centered on the focal region. This can be defined programmatically as follows.

```{r map-projection, echo=-1}
par(mar = c(0.25, 0.25, 0.25, 2))
# find the centroid of the region
region_centroid <- region_boundary |> 
  st_geometry() |> 
  st_transform(crs = 4326) |> 
  st_centroid() |> 
  st_coordinates() |> 
  round(1)

# define projection
crs_laea <- paste0("+proj=laea +lat_0=", region_centroid[2],
                   " +lon_0=", region_centroid[1])

# transform to the custom projection using nearest neighbor resampling
abd_breeding_laea <- project(abd_breeding_mask, crs_laea, method = "near") |> 
  trim()

# map the cropped and projected data
plot(abd_breeding_laea, axes = FALSE, breakby = "cases")
```

## Abundance bins

The relative abundance data are not uniformly distributed, which can lead to challenges distinguishing areas of differing levels of abundance. This is especially true for highly aggregatory species like shorebirds and ducks. To address this, we'll use a quantile bins for the map, where each color in the legend corresponds to an equal number of cells in the raster. We'll define these bins excluding zeros, then assign a separate color to the zeros. We can also use the function `abundance_palette()` to get the same set of colors we use in the legends on the eBird Status and Trends website.

```{r map-bins, echo=-1}
par(mar = c(0.25, 0.25, 0.25, 2))
# quantiles of non-zero values
v <- values(abd_breeding_laea, na.rm = TRUE, mat = FALSE)
v <- v[v > 0]
breaks <- quantile(v, seq(0, 1, by = 0.1))
# add a bin for 0
breaks <- c(0, breaks)

# status and trends palette
pal <- ebirdst_palettes(length(breaks) - 2)
# add a color for zero
pal <- c("#e6e6e6", pal)

# map using the quantile bins
plot(abd_breeding_laea, breaks = breaks, col = pal, axes = FALSE)
```

## Basemap

Finally, we'll add state and country boundaries to provide some context and generate a nicer legend. The R package `rnaturalearth` is an excellent source of attribution free contextual GIS data.

```{r map-basemap, echo=-1}
par(mar = c(0.25, 0.25, 0.25, 0.25))
# natural earth boundaries
countries <- ne_countries(returnclass = "sf") |> 
  st_geometry() |> 
  st_transform(crs_laea)
states <- ne_states(iso_a2 = "US", returnclass = "sf") |> 
  st_geometry() |> 
  st_transform(crs_laea)

# define the map plotting extent with the region boundary polygon
region_boundary_laea <- region_boundary |> 
  st_geometry() |> 
  st_transform(crs_laea)
plot(region_boundary_laea)
# add basemap
plot(countries, col = "#cfcfcf", border = "#888888", add = TRUE)
# add relative abundance
plot(abd_breeding_mask, 
     breaks = breaks, col = pal, 
     maxcell = ncell(abd_breeding_laea),
     legend = FALSE, add = TRUE)
# add boundaries
lines(vect(countries), col = "#ffffff", lwd = 3)
lines(vect(states), col =  "#ffffff", lwd = 1.5, xpd = TRUE)
lines(vect(region_boundary_laea), col = "#ffffff", lwd = 3, xpd = TRUE)

# add legend using the fields package
# label the bottom, middle, and top
labels <- quantile(breaks, c(0, 0.5, 1))
label_breaks <- seq(0, 1, length.out = length(breaks))
image.plot(zlim = c(0, 1), breaks = label_breaks, col = pal,
           smallplot = c(0.90, 0.93, 0.15, 0.85),
           legend.only = TRUE,
           axis.args = list(at = c(0, 0.5, 1), 
                            labels = round(labels, 2),
                            col.axis = "black", fg = NA,
                            cex.axis = 0.9, lwd.ticks = 0,
                            line = -0.5))
```

# Migration chronologies {#chron}

In this application we'll use the weekly estimates to chart the change in relative abundance throughout the year for a given region.

Next, we'll look at the temporal component of the relative abundance data. Using the weekly relative abundance, we can chart the change in relative abundance throughout the year for a given region. We'll start by looking at the Furthermore, using the upper and lower confidence interval rasters, we can add uncertainty estimates. We often refer to these as migration chronologies.

Let's start by loading all the necessary relative abundance cubes.

```{r chron_load}
abd_median <- load_raster("yebsap-example", product = "abundance", 
                          metric = "median", resolution = "27km")
abd_lower <- load_raster("yebsap-example", product = "abundance",
                         metric = "lower", resolution = "27km")
abd_upper <- load_raster("yebsap-example", product = "abundance", 
                         metric = "upper", resolution = "27km")
```

Now we'll extract the values for a fixed location.

```{r chron_extract}
# set a point
pt <- st_point(c(-88.1, 46.7)) %>% 
  st_sfc(crs = 4326) %>% 
  st_transform(crs = st_crs(abd_median)) %>% 
  st_coordinates()

# extract
chron_median <- as.matrix(extract(abd_median, pt))[1, ]
chron_upper <- as.matrix(extract(abd_upper, pt))[1, ]
chron_lower <- as.matrix(extract(abd_lower, pt))[1, ]

# plot chronology
chron <- data.frame(x = seq_len(length(chron_median)),
                    y = unname(chron_median),
                    lower = unname(chron_upper),
                    upper = unname(chron_lower))
ggplot(chron, aes(x, y)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              alpha = 0.3) +
  ylab("Relative abundance") +
  xlab("Week") +
  theme_light()
```

# Regional statistics {#stats}

In addition to maps and visualizations, the eBird Status and Trends website provides a set of statistics summarizing the spatial data over regions (countries and states) and seasons. The five regional statistics are:

1. **Mean relative abundance:** the average estimated relative abundance within the given region.
2. **Proportion of seasonal population:** the sum of the estimated relative abundance within the selected region divided by the sum of the estimated relative abundance across the full range.
3. **Proportion of region occupied:** the proportion of the selected region within the range boundary of a species.
4. **Proportion of range in region:** the proportion of a species' total range that falls within the selected region.
5. **Days of occupation in region:** the number of days that a species occupies the selected region, with occupation being defined as spatially covering the selected region by at least 5% based on estimated relative abundances averaged across the given season.

These statistics can be downloaded from the Status and Trends website for all regions and seasons for any given species; however, there may be situations where you want to calculate them over different regions than those provided. With that in mind, in this section we'll cover how to calculate a couple of these statistics: percent of population in region and percent of region occupied. The remaining 3 statistics can be calculated following the same approach with some modifications.

Since the example data used in this vignette is restricted to Michigan, we'll calculate the statistics over the counties in Michigan; however, this approach can easily be extended to any set of regions. Let's start by downloading county boundaries for Michigan.

```{r stats_counties}
mi_counties <- gadm(country = "USA", level = 2, path = tempdir()) %>% 
  st_as_sf() %>% 
  filter(NAME_1 == "Michigan") %>% 
  select(county = NAME_2, county_code = HASC_2) %>% 
  # remove lakes which aren't true counties
  filter(county_code != "US.MI.WB")
# project to sinusoidal
mi_counties_proj <- st_transform(mi_counties, crs = st_crs(abd_median))
```

We'll need the seasonal proportion of population cubes and the seasonal ranges for these calculations.

```{r stats_load}
pop_seasonal <- load_raster("yebsap-example", product = "proportion-population", 
                            period = "seasonal", resolution = "27km")
ranges <- load_ranges("yebsap-example", resolution = "27km", smoothed = FALSE)
```

## Proportion of population

Percent of population in regions is one of the simplest statistics to calculate since a raster of percent of population is already provided; we simply sum all the raster cells within each region polygon. 

```{r mean-rel-abd}
prop_pop <- extract(pop_seasonal, mi_counties_proj, fun = sum, na.rm = TRUE) %>% 
  # attach county attributes
  mutate(county_code = mi_counties$county_code) %>% 
  # transpose to long format, one season per row
  select(-ID) %>% 
  pivot_longer(cols = -county_code, 
               names_to = "season",
               values_to = "proportion_population")
head(prop_pop)
```

Let's make a quick map comparing the breeding and non-breeding proportion of population within counties in Michigan.

```{r stats_pop}
# join back to county boundaries
prop_pop_proj <- prop_pop %>% 
  filter(season %in% c("breeding", "nonbreeding")) %>%
  inner_join(mi_counties, ., by = "county_code") %>% 
  # transform to custom projection for plotting
  st_transform(crs = crs)

# plot
ggplot(prop_pop_proj) +
  geom_sf(aes(fill = proportion_population)) +
  scale_fill_viridis_c(trans = "sqrt") +
  guides(fill = guide_colorbar(title.position = "top", barwidth = 15)) +
  facet_wrap(~ season, ncol = 2) +
  labs(title = "Seasonal proportion of population in MI counties",
       fill = "Proportion of population") +
  theme_bw() +
  theme(legend.position = "bottom")
```

## Proportion of region occupied

To calculate range-based stats it's often easiest to use the range polygons rather than the raster data. We can calculate the area of each county, then calculate the area of intersection between the counties and the ranges, and finally divide the two to get the proportion of each region occupied.

```{r stats_occ}
# add the area of each region
mi_counties$area <- st_area(mi_counties)
# for each season, intersect with the county boundaries and calculate area
range_pct_occupied <- NULL
for (s in ranges$season) {
  range_pct_occupied <- ranges %>% 
    filter(season == s) %>% 
    st_intersection(mi_counties, .) %>% 
    mutate(proportion_occupied = as.numeric(st_area(.) / area)) %>% 
    select(season, county_code, proportion_occupied) %>% 
    st_drop_geometry() %>% 
    bind_rows(range_pct_occupied, .)
}
head(range_pct_occupied)
```
